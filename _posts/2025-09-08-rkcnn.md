---
title: "Random k Conditional Nearest Neighbor for High-Dimensional Data"
date: 2025-09-08
permalink: /posts/2025/09/rkcnn/
excerpt: "RkCNN extends kNN with random feature subsets and separation-based weighting, making nearest-neighbor methods competitive again in high-dimensional classification."
tags:
    - machine learning
    - kNN
    - ensemble methods
    - high-dimensional data
---

When you first learn machine learning, **k-nearest neighbors (kNN)** is usually one of the first algorithms you encounter. It's simple, take a new point, look at its nearest neighbors, and classify it by majority vote. Despite its simplicity, kNN has powered applications ranging from disease diagnosis to economic forecasting.  

But there's a catch, once you move to **high-dimensional data**, say tens of thousands of genes in a microarray dataset, the classic kNN starts to break down. Distances become less meaningful, and the presence of thousands of noisy features drowns out the signal.  

This is exactly the challenge addressed in the paper [***“Random k Conditional Nearest Neighbor for High-Dimensional Data”***](https://peerj.com/articles/cs-2497.pdf). The authors propose **RkCNN**, a clever ensemble approach that rethinks how nearest-neighbor methods can work in noisy, high-dimensional settings.  


## The Core Idea
RkCNN builds on **k conditional nearest neighbor (kCNN)**, a variant of kNN that estimates class probabilities in addition to predictions. The twist is to apply kCNN on **many random subsets of features**, and then weight these subsets based on how informative they are.  

Here's the recipe:
1. **Random subsets of features** are sampled from the original feature space.  
2. For each subset, a **separation score** is computed, essentially a ratio of between-class to within-class variance, inspired by Fisher's LDA.  
3. Only the top-scoring subsets are kept. The rest are discarded as noise.  
4. Predictions from these subsets are combined into an ensemble, weighted by their separation scores.  

This way, RkCNN avoids giving equal voice to noisy feature groups and instead highlights the *good* subspaces where the classes are clearly separated.  


## Why This Works
If you're familiar with **random forests**, the idea will sound familiar: sample random feature subsets, build weak classifiers, then combine them. RkCNN takes the same philosophy but applies it to the kNN family.  

- **Randomness** reduces overfitting and explores different feature interactions.  
- **Separation-based weighting** ensures that only useful subsets get influence.  
- **Ensembling** balances variance and bias, making the method robust even when classes overlap.  

In other words, RkCNN turns a very local, distance-sensitive method into a **stable ensemble classifier** that can survive the curse of dimensionality.  


## Simulations and Insights
The authors put RkCNN through extensive simulations, tweaking parameters like:  
- **k:** number of neighbors considered  
- **m:** size of each random feature subset  
- **r:** number of top subsets to keep  
- **h:** total number of subsets generated  

Some takeaways stood out:
- **Small k works best:** With large k, the model becomes too biased. With small k, the ensemble averaging keeps variance under control.  
- **Moderate subset sizes (m):** Too small, and you miss feature interactions. Too large, and noisy features dominate.  
- **Large r, flexible h:** Keeping more top subsets improves stability, but generating extra subsets (bigger h) mainly helps in very noisy data.

Even when datasets were swamped with hundreds or thousands of irrelevant features, RkCNN maintained strong accuracy, while classic kNN and other variants fell apart.  


## Real-World Test
To validate the method, the authors tested RkCNN on **24 gene expression datasets** for cancer classification. These datasets are notoriously tricky:  
- Thousands of features (genes).  
- Very few samples (sometimes <50).  
- Severe class imbalance.  

Against strong baselines like **random forests** and **SVMs**, RkCNN consistently ranked at or near the top. It outperformed all other nearest-neighbor-based methods in most datasets and achieved the best average accuracy and Matthews correlation coefficient (MCC).  

This is significant, it shows that **nearest-neighbor methods, when adapted properly, can compete with heavyweights** traditionally favored in high-dimensional bioinformatics.


## Why It Matters
High-dimensional data isn't just about biology, it's also common in text mining, finance, or image analysis. These domains often share the same challenge: a huge feature space with only a few truly informative dimensions.  

RkCNN demonstrates that:
- **Nearest-neighbor methods aren't obsolete**, they just need smarter design.  
- **Ensemble thinking + feature subspaces** can turn simple algorithms into state-of-the-art contenders.  
- **Interpretability improves:** The separation score provides a clear measure of which subsets (or indirectly, which features) are driving classification.  


## Closing Thoughts
I find RkCNN particularly exciting because it revives a classic algorithm with modern ensemble tricks. It's lightweight, intuitive, and surprisingly competitive against models like SVM and RF that usually dominate in high-dimensional settings.  

For practitioners, it offers a new option when faced with noisy datasets. For researchers, it opens doors to even more hybrid methods, for instance, could separation-score weighting inspire new **feature selection techniques**?  

Sometimes, innovation in ML isn't about inventing something brand new, as we have seen in previous posts, it's about taking a familiar tool and **finding a way to make it thrive in places it wasn't supposed to work**. RkCNN feels like exactly that.  


## Try It Yourself  

If you want to play around with RkCNN, I’ve made a fork of the official repo and used a real dataset in a Python notebook:  

[RkCNN on GitHub](https://github.com/josep-audenis/RkCNN)

You can clone it, tweak parameters like *k*, *m*, *r*, and *h*, and see how the algorithm behaves on a real dataset.

---

What do you think? Could methods like RkCNN bring classic algorithms like kNN back into the spo tlight for high-dimensional problems, or are ensemble methods like random forests still the safer bet?

Drop your thoughts in the comments. I’d love to hear how you’d use something like this. And if you found this breakdown useful, stick around, I’ll be diving into more research papers.